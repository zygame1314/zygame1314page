<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>D1 数据库天价账单背后的真相：一行代码引发的 7000 倍读写放大 - zygame1314</title>
</head>

<body>
    <main class="article-content">
        <div class="article-body">
            <h1>D1 数据库天价账单背后的真相：一行代码引发的 7000 倍读写放大</h1>

            <p class="article-intro">
                最近在维护小雅答答答的后端时，发现 Cloudflare D1 的 Rows Read 计费异常飙升。一个简单的用户活跃度更新操作，竟然每次都会读取 7000
                多行数据！本文记录了这次排查过程，揭示了一个隐藏在 SQLite Trigger 和 FTS 全文索引背后的性能陷阱。
            </p>

            <h2>一、诡异的账单</h2>
            <p>事情的起因是监控面板上的一条异常数据。我们的用户表 <code>users</code> 只有 2185 行数据，但执行一条最简单的更新语句时，<code>Rows Read</code> 却高得离谱：</p>

            <pre><span class="language-label"><i class="fas fa-database"></i> SQL</span><button class="article-copy-button"><i class="fas fa-copy"></i> 复制</button><code class="language-sql">UPDATE users SET last_seen_at = ? WHERE platform_user_id = ?</code></pre>

            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>指标 (Metric)</th>
                            <th>数值 (Value)</th>
                            <th>评价 (Status)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Affected Rows</td>
                            <td>1</td>
                            <td>✅ 正常</td>
                        </tr>
                        <tr>
                            <td>Query Time</td>
                            <td>2.4ms</td>
                            <td>✅ 正常</td>
                        </tr>
                        <tr>
                            <td><strong>Rows Read</strong></td>
                            <td><strong>7884</strong></td>
                            <td>❌ <strong>极度异常 (3.6x 全表)</strong></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="explanation-box">
                <h4>💸 为什么这很严重？</h4>
                <p>Cloudflare D1 是按 <strong>Rows Read（读取行数）</strong> 计费的。虽然 2.4ms
                    的延迟用户感知不到，但对于钱包来说，这简直是由于“代码漏洞”引发的抢劫。每小时几百次的更新频率，迅速消耗了免费额度。</p>
            </div>

            <h2>二、沉浸式排查记录</h2>
            <p>为了找出原因，我们进行了一系列的假设和验证。以下是当时的排查日志：</p>

            <div class="chat-message sent">
                <div class="chat-avatar">🕵️</div>
                <div class="chat-content">
                    <div class="chat-name">排查员</div>
                    <p><strong>嫌疑人 1：缺少索引？</strong><br>
                        我们的 <code>platform_user_id</code> 是 <code>TEXT PRIMARY KEY</code>。在 SQLite 中，TEXT 主键的索引是隐式的。难道是
                        D1 没有正确使用它？</p>
                </div>
            </div>

            <div class="config-explanation">
                <p>尝试操作：添加显式唯一索引</p>
                <pre><span class="language-label"><i class="fas fa-code"></i> SQL</span><code class="language-sql">CREATE UNIQUE INDEX idx_users_pid ON users(platform_user_id);</code></pre>
            </div>

            <div class="chat-message">
                <div class="chat-avatar">🤖</div>
                <div class="chat-content">
                    <div class="chat-name">系统反馈</div>
                    <p><strong>结果失败：</strong> <code>Rows Read</code> 依然是 7884。即使显式加了索引，读取量没有丝毫下降。</p>
                </div>
            </div>

            <div class="chat-message sent">
                <div class="chat-avatar">🕵️</div>
                <div class="chat-content">
                    <div class="chat-name">排查员</div>
                    <p><strong>嫌疑人 2：统计延迟？</strong><br>
                        也许 Dashboard 显示的是历史平均值？让我直接跑一个 SELECT 试试。</p>
                </div>
            </div>

            <div class="config-explanation">
                <pre><span class="language-label"><i class="fas fa-search"></i> SQL</span><code class="language-sql">SELECT * FROM users WHERE platform_user_id = 'xxx';</code></pre>
            </div>

            <div class="chat-message">
                <div class="chat-avatar">🤖</div>
                <div class="chat-content">
                    <div class="chat-name">系统反馈</div>
                    <p><strong>结果正常：</strong> <code>Rows Read: 1</code>。这证明索引是完好无损的，读取操作非常高效。问题仅存在于
                        <strong>写入/更新</strong> 时。
                    </p>
                </div>
            </div>

            <div class="chat-message sent">
                <div class="chat-avatar">🕵️</div>
                <div class="chat-content">
                    <div class="chat-name">排查员</div>
                    <p><strong>嫌疑人 3：物理行 ID 更新？</strong><br>
                        绝望之下，我们尝试绕过业务主键，直接使用 SQLite 的物理行 ID <code>_rowid_</code> 进行更新。</p>
                </div>
            </div>

            <div class="config-explanation">
                <pre><span class="language-label"><i class="fas fa-microchip"></i> SQL</span><code class="language-sql">UPDATE users SET last_seen_at = 123 WHERE _rowid_ = 2;</code></pre>
            </div>

            <div class="chat-message">
                <div class="chat-avatar">🤖</div>
                <div class="chat-content">
                    <div class="chat-name">系统反馈</div>
                    <p><strong>结果依然炸裂：</strong> <code>Rows Read</code> 还是
                        7884！这彻底排除了“索引失效”的可能性。问题一定出在<strong>更新这个动作本身触发的副作用</strong>上。</p>
                </div>
            </div>

            <h2>三、真相大白</h2>
            <p>既然不是查询的问题，那肯定是触发了什么东西。我们检查了数据库的 Trigger（触发器）列表，终于在角落里发现了一个名为 <code>users_au</code> (Users After Update)
                的触发器：</p>

            <pre><span class="language-label"><i class="fas fa-bomb"></i> SQL</span><code class="language-sql">CREATE TRIGGER users_au AFTER UPDATE ON users 
BEGIN
    UPDATE activations_fts 
    SET realname = NEW.realname, 
        school_info = NEW.school_info 
    WHERE used_by_user_id = NEW.platform_user_id; -- ⚠️ 罪魁祸首在此！
END;</code></pre>

            <p>这个触发器的初衷是好的：当用户在 <code>users</code> 表中修改名字时，自动同步到 <code>activations_fts</code> 表方便搜索。但是它犯了两个致命错误：</p>

            <div class="article-tips">
                <ul>
                    <li><strong>致命错误 1 (无条件触发)：</strong> 只要 <code>users</code> 表有任何更新（哪怕是你只更新了最后在线时间
                        <code>last_seen_at</code>），它都会运行。
                    </li>
                    <li><strong>致命错误 2 (FTS 全表扫描)：</strong> <code>activations_fts</code> 是一个全文索引虚拟表。它对文本搜索很快，但对
                        <code>used_by_user_id</code> 这种普通列<strong>没有索引</strong>！
                    </li>
                </ul>
            </div>

            <p>所以，每次用户刷新页面更新在线时间时，数据库就会被迫去<strong>全表扫描</strong>那张庞大的全文索引表，只为了确认名字有没有变。</p>

            <h2>四、一针见血的修复</h2>
            <p>修复方法非常简单，给触发器加上一个 <code>WHEN</code> 条件，告诉它：“只有当名字真的变了时，才去干活”。</p>

            <pre><span class="language-label"><i class="fas fa-check-circle"></i> SQL</span><button class="article-copy-button"><i class="fas fa-copy"></i> 复制</button><code class="language-sql">CREATE TRIGGER users_au AFTER UPDATE ON users 
WHEN (OLD.realname IS DISTINCT FROM NEW.realname) OR (OLD.school_info IS DISTINCT FROM NEW.school_info) -- ✨ 加上这行魔法代码
BEGIN
    UPDATE activations_fts ...
END;</code></pre>

            <h3>优化前后对比</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>场景</th>
                            <th>Rows Read (Before)</th>
                            <th>Rows Read (After)</th>
                            <th>提升幅度</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>更新最后在线时间</td>
                            <td>7884</td>
                            <td><strong>1</strong></td>
                            <td>🚀 <strong>7884x</strong></td>
                        </tr>
                        <tr>
                            <td>用户改名</td>
                            <td>7884</td>
                            <td>7884</td>
                            <td>- (必要开销)</td>
                        </tr>
                        <tr>
                            <td>日常 Token 刷新</td>
                            <td>7884</td>
                            <td><strong>1</strong></td>
                            <td>🚀 <strong>7884x</strong></td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h2>五、总结</h2>
            <div class="summary-box">
                <ul>
                    <li><strong>警惕隐形开销：</strong> 数据库 Trigger（触发器）是强大的工具，但也是隐藏的性能杀手。</li>
                    <li><strong>理解 Serverless 计费：</strong> 在 D1 这种按行计费的云数据库中，全表扫描不仅慢，而且贵。</li>
                    <li><strong>FTS 表的局限：</strong> 全文索引表（Generic Table）不适合做普通列的关系查询，除非那是 RowID。</li>
                </ul>
            </div>

            <div class="article-footer">
                <p>这次排查再次提醒我们：在云原生时代，写代码不仅要关注逻辑正确，更要关注底层实现带来的成本影响。希望这篇文章能帮到同样使用 D1 的开发者们！</p>
            </div>
        </div>
    </main>
</body>

</html>